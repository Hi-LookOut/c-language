# splitFile 

## 是一个关于在window下使用fopen/fgets分割文件的demo。
#### 下面记录在写的过程中遇到了分割文件乱码的坑和解决的方法。
---

### 乱码发生可能的原因
   - 文件存储的格式
   - 文件分割后，发现第一个文件最后一个字符乱码，后面文件大部分乱码。
   - fgets函数的减1问题，导致前面一些文字不乱码，后面的乱码。
   
### 解决方法
   
1. 格式问题:

      读的文件编码集与存储文件的编码集不对应。
       基础知识：https://blog.csdn.net/silently_frog/article/details/96494434（最好使用utf-8）
       
      由于我读取的文件是格式是ANSI,而输出文件也必须是ANSI.除非手动转码。
      
2. 最后一个字符乱码问题

   由于我存在文件中只用中文字，用的ANSI编码，每个中文字占两个字节。在文件分割时，一定要考虑每一个分割文件最后一个中文字所占的两字节是否被分割。

   > 举个例子： 将存有 ：我不敢说也不敢问啊 9个字的文件分到2个文件中，如果是 按总字节数除以2的话，后面就乱                                             码。

   > 9个文字占18个字节， 平分的话一个文件9个字节，但是我们要显示一个char,需要2个字节，于是第一个文件最后一个是乱码。而第二个文件都是乱码。
   
   
3. 读取文件中含有中文有含有字母等占字节不同的字符。导致分割时不好计算每个分割文件的大小。容易导致问题2的情况出现。


4. c字符数组问题，导致我们用fgets与fwrite函数时所产生的问题。

      先看其实现：
      
      char *fgets(char *s, int n,  FILE *stream)
      
      {
      
          register int c;
          register char *cs;
          cs = s;

          while(--n > 0 && (c = getc(stream)) != EOF)
          {
              if((*cs++ =   c) == '\n')
              {
                 break;
              }
          }

         *cs = '\0';
         return (c == EOF && cs == s) ? NULL : s ;
      }

    我们注意看23行 --n>0
    
    n代表读取字节的个数，这样就导致我们只循环了n-1次，说明我们只取了n-1个字节。
    
    举个例子：
    
    我们要读取一个文件中（我爱你）三个文字，那么n=6，如果用fgets最终只读取了5个字节，从而导致（你）显示为乱码。
    解决方法当然是传入n+1。
     
    为啥要这样？？？
    
    主要的原因-----还是因为在c中字符数组的最后一位必须以\0结尾。所以我们 char buff[50],其实它的容量只用49。所以fgets会去减去1.
   
